/**
 * Markdown Structure Utility
 * 
 * A simplified utility for formatting and parsing markdown without
 * converting to HTML or using AST, just using string operations.
 */

/**
 * Format RedHawk assistant response as structured markdown
 * @param {string} response - Raw assistant response
 * @param {Object} metadata - Metadata for the response
 * @returns {string} Formatted markdown
 */
function formatRedHawkResponse(response, metadata = {}) {
  const { logAnalysis, securityLevel = 'Unknown', timestamp = new Date().toISOString() } = metadata;
  
  let markdownContent = `# RedHawk Security Analysis\n\n`;
  
  // Add metadata section
  markdownContent += `**Analysis Time**: ${new Date(timestamp).toLocaleString()}\n`;
  markdownContent += `**Security Level**: ${securityLevel}\n\n`;
  
  // Add main response
  markdownContent += `## Analysis Results\n\n${response}\n\n`;
  
  // Add log analysis details if available
  if (logAnalysis) {
    if (logAnalysis.recommendedActions && logAnalysis.recommendedActions.length > 0) {
      markdownContent += `## Recommended Actions\n\n`;
      logAnalysis.recommendedActions.forEach(action => {
        markdownContent += `- ${action}\n`;
      });
      markdownContent += '\n';
    }
    
    if (logAnalysis.predictionCounts) {
      markdownContent += `## Log Entry Classifications\n\n`;
      markdownContent += '| Category | Count | Percentage |\n';
      markdownContent += '|----------|-------|------------|\n';
      
      for (const [category, count] of Object.entries(logAnalysis.predictionCounts)) {
        const percentage = logAnalysis.predictionPercentages && 
                         logAnalysis.predictionPercentages[category] || 'N/A';
        
        markdownContent += `| ${category} | ${count} | ${percentage} |\n`;
      }
      markdownContent += '\n';
    }
  }
  
  // Add footer
  markdownContent += `---\n\n`;
  markdownContent += `*This analysis was generated by RedHawk Assistant. Always verify security findings with your team.*`;
  
  return markdownContent;
}

/**
 * Parse a RedHawk markdown response into structured data using regex
 * @param {string} markdown - Formatted markdown response
 * @returns {Object} Structured data
 */
function parseRedHawkResponse(markdown) {
  // Basic structure for the result
  const result = {
    title: '',
    securityLevel: 'Unknown',
    analysisTime: null,
    analysisResults: '',
    recommendedActions: [],
    logClassifications: []
  };
  
  // Extract title (first h1)
  const titleMatch = markdown.match(/# ([^\n]+)/);
  if (titleMatch) {
    result.title = titleMatch[1].trim();
  }
  
  // Extract security level
  const securityLevelMatch = markdown.match(/\*\*Security Level\*\*:\s*([^\n]+)/);
  if (securityLevelMatch) {
    result.securityLevel = securityLevelMatch[1].trim();
  }
  
  // Extract analysis time
  const timeMatch = markdown.match(/\*\*Analysis Time\*\*:\s*([^\n]+)/);
  if (timeMatch) {
    result.analysisTime = timeMatch[1].trim();
  }
  
  // Extract analysis results
  const analysisSection = markdown.match(/## Analysis Results\s*\n\n([^#]+)/);
  if (analysisSection) {
    result.analysisResults = analysisSection[1].trim();
  }
  
  // Extract recommended actions
  const actionsSectionMatch = markdown.match(/## Recommended Actions\s*\n\n((?:- [^\n]+\n)+)/);
  if (actionsSectionMatch) {
    const actionsList = actionsSectionMatch[1];
    const actionsMatches = actionsList.matchAll(/- ([^\n]+)/g);
    for (const match of actionsMatches) {
      result.recommendedActions.push(match[1].trim());
    }
  }
  
  // Extract log classifications table
  const tableMatch = markdown.match(/\| Category \| Count \| Percentage \|\n\|[^\n]+\|\n((?:\|[^\n]+\|\n)+)/);
  if (tableMatch) {
    const tableRows = tableMatch[1].trim().split('\n');
    tableRows.forEach(row => {
      const cells = row.split('|').filter(cell => cell.trim());
      if (cells.length >= 3) {
        result.logClassifications.push({
          category: cells[0].trim(),
          count: cells[1].trim(),
          percentage: cells[2].trim()
        });
      }
    });
  }
  
  return result;
}

/**
 * Extract sections from markdown
 * @param {string} markdown - Markdown text
 * @returns {Object} Map of section titles to content
 */
function extractSections(markdown) {
  const sections = {};
  
  // Match all h2 sections
  const sectionMatches = markdown.matchAll(/## ([^\n]+)\s*\n\n([^#]+?)(?=\n\n##|$)/g);
  
  for (const match of sectionMatches) {
    const sectionTitle = match[1].trim();
    const sectionContent = match[2].trim();
    sections[sectionTitle] = sectionContent;
  }
  
  return sections;
}

/**
 * Extract bullet points from a section
 * @param {string} sectionContent - Content of a markdown section
 * @returns {Array} List of bullet points
 */
function extractBulletPoints(sectionContent) {
  const bulletPoints = [];
  const matches = sectionContent.matchAll(/- ([^\n]+)/g);
  
  for (const match of matches) {
    bulletPoints.push(match[1].trim());
  }
  
  return bulletPoints;
}

module.exports = {
  formatRedHawkResponse,
  parseRedHawkResponse,
  extractSections,
  extractBulletPoints
}; 