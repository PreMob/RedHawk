/**
 * Markdown Parser for RedHawk Assistant
 * 
 * Parses markdown and maintains structure for formatting in various outputs
 */

const { unified } = require('unified');
const remarkParse = require('remark-parse');
const { visit } = require('unist-util-visit');

/**
 * Parse markdown text and return its structure
 * @param {string} markdown - Raw markdown text to parse
 * @returns {Object} Parsed markdown structure
 */
function parseMarkdown(markdown) {
  const processor = unified().use(remarkParse);
  const ast = processor.parse(markdown);
  return ast;
}

/**
 * Extract structured data from markdown content
 * @param {string} markdown - Raw markdown text
 * @returns {Object} Structured data extracted from markdown
 */
function extractStructuredData(markdown) {
  const ast = parseMarkdown(markdown);
  
  const result = {
    title: null,
    sections: [],
    lists: [],
    codeBlocks: [],
    tables: []
  };
  
  // Extract title (first h1)
  visit(ast, 'heading', (node) => {
    if (node.depth === 1 && !result.title) {
      result.title = getTextFromNode(node);
    }
  });
  
  // Extract sections (h2 and content until next h2)
  visit(ast, 'heading', (node) => {
    if (node.depth === 2) {
      result.sections.push({
        title: getTextFromNode(node),
        content: getContentUntilNextHeading(node, ast)
      });
    }
  });
  
  // Extract lists
  visit(ast, 'list', (node) => {
    const items = node.children.map(item => {
      return getTextFromNode(item);
    });
    
    result.lists.push({
      ordered: node.ordered,
      items: items
    });
  });
  
  // Extract code blocks
  visit(ast, 'code', (node) => {
    result.codeBlocks.push({
      language: node.lang || 'text',
      value: node.value
    });
  });
  
  return result;
}

/**
 * Format RedHawk assistant response as structured markdown
 * @param {string} response - Raw assistant response
 * @param {Object} metadata - Metadata for the response
 * @returns {string} Formatted markdown
 */
function formatRedHawkResponse(response, metadata = {}) {
  const { logAnalysis, securityLevel = 'Unknown', timestamp = new Date().toISOString() } = metadata;
  
  let markdownContent = `# RedHawk Security Analysis\n\n`;
  
  // Add metadata section
  markdownContent += `**Analysis Time**: ${new Date(timestamp).toLocaleString()}\n`;
  markdownContent += `**Security Level**: ${securityLevel}\n\n`;
  
  // Add main response
  markdownContent += `## Analysis Results\n\n${response}\n\n`;
  
  // Add log analysis details if available
  if (logAnalysis) {
    if (logAnalysis.recommendedActions && logAnalysis.recommendedActions.length > 0) {
      markdownContent += `## Recommended Actions\n\n`;
      logAnalysis.recommendedActions.forEach(action => {
        markdownContent += `- ${action}\n`;
      });
      markdownContent += '\n';
    }
    
    if (logAnalysis.predictionCounts) {
      markdownContent += `## Log Entry Classifications\n\n`;
      markdownContent += '| Category | Count | Percentage |\n';
      markdownContent += '|----------|-------|------------|\n';
      
      for (const [category, count] of Object.entries(logAnalysis.predictionCounts)) {
        const percentage = logAnalysis.predictionPercentages && 
                         logAnalysis.predictionPercentages[category] || 'N/A';
        
        markdownContent += `| ${category} | ${count} | ${percentage} |\n`;
      }
      markdownContent += '\n';
    }
  }
  
  // Add footer
  markdownContent += `---\n\n`;
  markdownContent += `*This analysis was generated by RedHawk Assistant. Always verify security findings with your team.*`;
  
  return markdownContent;
}

/**
 * Parse a RedHawk markdown response into structured data
 * @param {string} markdown - Formatted markdown response
 * @returns {Object} Structured data
 */
function parseRedHawkResponse(markdown) {
  const structure = extractStructuredData(markdown);
  
  // Extract more specific RedHawk data
  const result = {
    title: structure.title,
    securityLevel: 'Unknown',
    analysisTime: null,
    analysisResults: null,
    recommendedActions: [],
    logClassifications: []
  };
  
  // Extract metadata from the content
  const metadataMatch = markdown.match(/\*\*Security Level\*\*:\s*([^\n]+)/);
  if (metadataMatch) {
    result.securityLevel = metadataMatch[1].trim();
  }
  
  const timeMatch = markdown.match(/\*\*Analysis Time\*\*:\s*([^\n]+)/);
  if (timeMatch) {
    result.analysisTime = timeMatch[1].trim();
  }
  
  // Extract analysis results
  const analysisSection = structure.sections.find(s => s.title === 'Analysis Results');
  if (analysisSection) {
    result.analysisResults = analysisSection.content;
  }
  
  // Extract recommended actions
  const actionsList = structure.lists.find(list => {
    // Find the list that comes after "Recommended Actions" heading
    const actionIndex = markdown.indexOf('## Recommended Actions');
    if (actionIndex === -1) return false;
    
    const listStr = JSON.stringify(list);
    return markdown.indexOf(listStr) > actionIndex;
  });
  
  if (actionsList) {
    result.recommendedActions = actionsList.items;
  }
  
  // Try to parse table data for classifications
  const tableMatch = markdown.match(/\| Category \| Count \| Percentage \|\n\|[^\n]+\|\n((?:\|[^\n]+\|\n)+)/);
  if (tableMatch) {
    const tableRows = tableMatch[1].trim().split('\n');
    tableRows.forEach(row => {
      const cells = row.split('|').filter(cell => cell.trim());
      if (cells.length >= 3) {
        result.logClassifications.push({
          category: cells[0].trim(),
          count: cells[1].trim(),
          percentage: cells[2].trim()
        });
      }
    });
  }
  
  return result;
}

// Helper functions
function getTextFromNode(node) {
  if (node.type === 'text') {
    return node.value;
  }
  
  if (!node.children) return '';
  
  return node.children.map(child => {
    return getTextFromNode(child);
  }).join('');
}

function getContentUntilNextHeading(headingNode, ast) {
  let content = '';
  let capturing = false;
  let foundHeading = false;
  
  ast.children.forEach(node => {
    if (node === headingNode) {
      capturing = true;
      foundHeading = true;
      return;
    }
    
    if (foundHeading && node.type === 'heading' && node.depth <= headingNode.depth) {
      capturing = false;
    }
    
    if (capturing && node !== headingNode) {
      content += nodeToMarkdown(node);
    }
  });
  
  return content.trim();
}

function nodeToMarkdown(node) {
  if (node.type === 'paragraph') {
    return node.children.map(getTextFromNode).join('') + '\n\n';
  }
  
  if (node.type === 'code') {
    return '```' + (node.lang || '') + '\n' + node.value + '\n```\n\n';
  }
  
  if (node.type === 'list') {
    return node.children.map((item, i) => {
      const bullet = node.ordered ? `${i + 1}. ` : '- ';
      return bullet + getTextFromNode(item) + '\n';
    }).join('') + '\n';
  }
  
  if (node.type === 'text' || node.type === 'inlineCode' || node.type === 'emphasis' || node.type === 'strong') {
    return getTextFromNode(node);
  }
  
  return '';
}

module.exports = {
  parseMarkdown,
  extractStructuredData,
  formatRedHawkResponse,
  parseRedHawkResponse
}; 